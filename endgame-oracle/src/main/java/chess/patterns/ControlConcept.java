package chess.patterns;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import chess.Piece;
import chess.PieceType;
import chess.SideToMove;

import tablebases.TablebaseWithSTM;

/**
 * An idea in chess concerned with one entity controlling (e.g., attacking,
 * defending) another entity.
 * 
 * @author Kestutis
 * 
 */
public enum ControlConcept implements ChessConcept {

    PIECE_CONTROLS_PIECE {

	@Override
	public Set<ChessPattern> generateChessPatterns(
		TablebaseWithSTM tablebaseWithStm) {
	    Set<ChessPattern> patterns = new HashSet<>();
	    List<Piece> pieces = tablebaseWithStm.getTablebase().getAllPieces();
	    SideToMove sideToMove = tablebaseWithStm.getSideToMove();
	    int totalPieces = pieces.size();
	    for (int i = 0; i < totalPieces; i++) {
		ControllerEntity controllingPiece = pieces.get(i);
		for (int j = 0; j < totalPieces; j++) {
		    ControllableEntity pieceUnderControl = pieces.get(j);
		    if (	i != j 
			    && !bothPiecesAreKings(
			    		(Piece) controllingPiece, 
			    		(Piece) pieceUnderControl)
			    && !kingIsUnderCheckButOpponentIsToMove(
				       	(Piece) pieceUnderControl, sideToMove)
			    && !kingIsControlledBySameColourPiece(
			    		(Piece) controllingPiece, 
			    		(Piece) pieceUnderControl)) {
			String name = patternName(
				(Piece) controllingPiece, (Piece) pieceUnderControl);		    
			patterns.add(new ControlPattern(
				controllingPiece, pieceUnderControl, name));
		    }
		}		
	    }
	    return patterns;
	}

	/**
	 * Checks if both specified pieces are kings.
	 *
	 * @param piece1 first piece
	 * @param piece2 second (different) piece
	 * @return true, if both pieces are of KING type
	 */
	private boolean bothPiecesAreKings(Piece piece1, Piece piece2) {
	    return piece1.getPieceType() == PieceType.KING
		    && piece2.getPieceType() == PieceType.KING;
	}

	/**
	 * Checks if the King is under check, but at the same time the opposing
	 * side is to move (if true, that would mean an illegal position).
	 * 
	 * @param pieceUnderControl
	 *            the piece under control by another piece
	 * @param sideToMove
	 *            side whose turn is to make a move - White or Black
	 * @return true, if the King is attacked by an opponent piece, and it is
	 *         an opponent's turn to make a move
	 */
	private boolean kingIsUnderCheckButOpponentIsToMove(
		Piece pieceUnderControl, SideToMove sideToMove) {
	    return pieceUnderControl.getPieceType() == PieceType.KING
		    && !sideToMove.name().equals(pieceUnderControl.getPieceColour().name());
	}

	/**
	 * Checks if the King is "defended" by a friendly piece (such a defence
	 * is irrelevant, therefore the corresponding chess pattern would not
	 * make sense).
	 * 
	 * @param controllingPiece
	 *            the piece that controls (attacks / defends) another piece
	 * @param pieceUnderControl
	 *            the piece that is controlled (attacked / defended) by
	 *            another piece
	 * @return true, if the King is controlled by a piece of the same colour
	 */
	private boolean kingIsControlledBySameColourPiece(
		Piece controllingPiece, Piece pieceUnderControl) {
	    return pieceUnderControl.getPieceType() == PieceType.KING
		    && controllingPiece.getPieceColour() == pieceUnderControl
			    .getPieceColour();
	}

	/**
	 * Creates the name of the chess pattern generated by this chess
	 * concept.
	 * 
	 * @param controllingPiece
	 *            the piece that controls (attacks / defends) some other
	 *            piece
	 * @param pieceUnderControl
	 *            the piece that is under control (is attacked or defended)
	 *            by another piece
	 * @return the string representation of the pattern
	 */
	private String patternName(Piece controllingPiece,
		Piece pieceUnderControl) {
	    String name = controllingPiece.toString();
	    name += controllingPiece.getPieceColour() == pieceUnderControl.getPieceColour()
		    ? " defends " : " attacks ";
	    return name += pieceUnderControl;
	}

    }
    
    ;   

}

